// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLATPACKET_OBJECT_H_
#define FLATBUFFERS_GENERATED_FLATPACKET_OBJECT_H_

#include "flatbuffers/flatbuffers.h"

namespace object {

struct Packet;

struct LoginData;

struct SignUpData;

struct GameState;

struct AllUser;

struct UserInfo;

struct RoomList;

struct RoomInfo;

struct RoomUserInfo;

struct GameReadyInfo;

struct LeaveRoom;

struct GameStartInfo;

struct CheckPassword;

struct ChatMessage;

struct AttackInfo;

struct PlayerData;

struct Position;

struct Location;

struct Rotation;

struct Velocity;

struct GameResult;

struct TopRanking;

struct RankUser;

struct MonsterData;

struct SystemMessage;

struct SystemTime;

struct SpawnOK;

struct MoveMonster;

struct MoveOK;

struct SpawnMonsterData;

struct MyData;

struct Revival;

struct GameEnd;

struct ItemUsing;

struct RefreshItem;

struct ItemBuy;

struct BuyRequest;

enum Type {
  Type_NONE = 0,
  Type_LoginData = 1,
  Type_SignUpData = 2,
  Type_GameState = 3,
  Type_AllUser = 4,
  Type_RoomInfo = 5,
  Type_RoomList = 6,
  Type_GameReadyInfo = 7,
  Type_LeaveRoom = 8,
  Type_GameStartInfo = 9,
  Type_CheckPassword = 10,
  Type_ChatMessage = 11,
  Type_AttackInfo = 12,
  Type_PlayerData = 13,
  Type_GameResult = 14,
  Type_TopRanking = 15,
  Type_MonsterData = 16,
  Type_SystemMessage = 17,
  Type_SystemTime = 18,
  Type_SpawnOK = 19,
  Type_MoveMonster = 20,
  Type_MoveOK = 21,
  Type_SpawnMonsterData = 22,
  Type_MyData = 23,
  Type_Revival = 24,
  Type_GameEnd = 25,
  Type_ItemUsing = 26,
  Type_RefreshItem = 27,
  Type_ItemBuy = 28,
  Type_BuyRequest = 29,
  Type_MIN = Type_NONE,
  Type_MAX = Type_BuyRequest
};

inline const Type (&EnumValuesType())[30] {
  static const Type values[] = {
    Type_NONE,
    Type_LoginData,
    Type_SignUpData,
    Type_GameState,
    Type_AllUser,
    Type_RoomInfo,
    Type_RoomList,
    Type_GameReadyInfo,
    Type_LeaveRoom,
    Type_GameStartInfo,
    Type_CheckPassword,
    Type_ChatMessage,
    Type_AttackInfo,
    Type_PlayerData,
    Type_GameResult,
    Type_TopRanking,
    Type_MonsterData,
    Type_SystemMessage,
    Type_SystemTime,
    Type_SpawnOK,
    Type_MoveMonster,
    Type_MoveOK,
    Type_SpawnMonsterData,
    Type_MyData,
    Type_Revival,
    Type_GameEnd,
    Type_ItemUsing,
    Type_RefreshItem,
    Type_ItemBuy,
    Type_BuyRequest
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[] = {
    "NONE",
    "LoginData",
    "SignUpData",
    "GameState",
    "AllUser",
    "RoomInfo",
    "RoomList",
    "GameReadyInfo",
    "LeaveRoom",
    "GameStartInfo",
    "CheckPassword",
    "ChatMessage",
    "AttackInfo",
    "PlayerData",
    "GameResult",
    "TopRanking",
    "MonsterData",
    "SystemMessage",
    "SystemTime",
    "SpawnOK",
    "MoveMonster",
    "MoveOK",
    "SpawnMonsterData",
    "MyData",
    "Revival",
    "GameEnd",
    "ItemUsing",
    "RefreshItem",
    "ItemBuy",
    "BuyRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<LoginData> {
  static const Type enum_value = Type_LoginData;
};

template<> struct TypeTraits<SignUpData> {
  static const Type enum_value = Type_SignUpData;
};

template<> struct TypeTraits<GameState> {
  static const Type enum_value = Type_GameState;
};

template<> struct TypeTraits<AllUser> {
  static const Type enum_value = Type_AllUser;
};

template<> struct TypeTraits<RoomInfo> {
  static const Type enum_value = Type_RoomInfo;
};

template<> struct TypeTraits<RoomList> {
  static const Type enum_value = Type_RoomList;
};

template<> struct TypeTraits<GameReadyInfo> {
  static const Type enum_value = Type_GameReadyInfo;
};

template<> struct TypeTraits<LeaveRoom> {
  static const Type enum_value = Type_LeaveRoom;
};

template<> struct TypeTraits<GameStartInfo> {
  static const Type enum_value = Type_GameStartInfo;
};

template<> struct TypeTraits<CheckPassword> {
  static const Type enum_value = Type_CheckPassword;
};

template<> struct TypeTraits<ChatMessage> {
  static const Type enum_value = Type_ChatMessage;
};

template<> struct TypeTraits<AttackInfo> {
  static const Type enum_value = Type_AttackInfo;
};

template<> struct TypeTraits<PlayerData> {
  static const Type enum_value = Type_PlayerData;
};

template<> struct TypeTraits<GameResult> {
  static const Type enum_value = Type_GameResult;
};

template<> struct TypeTraits<TopRanking> {
  static const Type enum_value = Type_TopRanking;
};

template<> struct TypeTraits<MonsterData> {
  static const Type enum_value = Type_MonsterData;
};

template<> struct TypeTraits<SystemMessage> {
  static const Type enum_value = Type_SystemMessage;
};

template<> struct TypeTraits<SystemTime> {
  static const Type enum_value = Type_SystemTime;
};

template<> struct TypeTraits<SpawnOK> {
  static const Type enum_value = Type_SpawnOK;
};

template<> struct TypeTraits<MoveMonster> {
  static const Type enum_value = Type_MoveMonster;
};

template<> struct TypeTraits<MoveOK> {
  static const Type enum_value = Type_MoveOK;
};

template<> struct TypeTraits<SpawnMonsterData> {
  static const Type enum_value = Type_SpawnMonsterData;
};

template<> struct TypeTraits<MyData> {
  static const Type enum_value = Type_MyData;
};

template<> struct TypeTraits<Revival> {
  static const Type enum_value = Type_Revival;
};

template<> struct TypeTraits<GameEnd> {
  static const Type enum_value = Type_GameEnd;
};

template<> struct TypeTraits<ItemUsing> {
  static const Type enum_value = Type_ItemUsing;
};

template<> struct TypeTraits<RefreshItem> {
  static const Type enum_value = Type_RefreshItem;
};

template<> struct TypeTraits<ItemBuy> {
  static const Type enum_value = Type_ItemBuy;
};

template<> struct TypeTraits<BuyRequest> {
  static const Type enum_value = Type_BuyRequest;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PACKET_TYPE_TYPE = 4,
    VT_PACKET_TYPE = 6
  };
  Type packet_type_type() const {
    return static_cast<Type>(GetField<uint8_t>(VT_PACKET_TYPE_TYPE, 0));
  }
  const void *packet_type() const {
    return GetPointer<const void *>(VT_PACKET_TYPE);
  }
  template<typename T> const T *packet_type_as() const;
  const LoginData *packet_type_as_LoginData() const {
    return packet_type_type() == Type_LoginData ? static_cast<const LoginData *>(packet_type()) : nullptr;
  }
  const SignUpData *packet_type_as_SignUpData() const {
    return packet_type_type() == Type_SignUpData ? static_cast<const SignUpData *>(packet_type()) : nullptr;
  }
  const GameState *packet_type_as_GameState() const {
    return packet_type_type() == Type_GameState ? static_cast<const GameState *>(packet_type()) : nullptr;
  }
  const AllUser *packet_type_as_AllUser() const {
    return packet_type_type() == Type_AllUser ? static_cast<const AllUser *>(packet_type()) : nullptr;
  }
  const RoomInfo *packet_type_as_RoomInfo() const {
    return packet_type_type() == Type_RoomInfo ? static_cast<const RoomInfo *>(packet_type()) : nullptr;
  }
  const RoomList *packet_type_as_RoomList() const {
    return packet_type_type() == Type_RoomList ? static_cast<const RoomList *>(packet_type()) : nullptr;
  }
  const GameReadyInfo *packet_type_as_GameReadyInfo() const {
    return packet_type_type() == Type_GameReadyInfo ? static_cast<const GameReadyInfo *>(packet_type()) : nullptr;
  }
  const LeaveRoom *packet_type_as_LeaveRoom() const {
    return packet_type_type() == Type_LeaveRoom ? static_cast<const LeaveRoom *>(packet_type()) : nullptr;
  }
  const GameStartInfo *packet_type_as_GameStartInfo() const {
    return packet_type_type() == Type_GameStartInfo ? static_cast<const GameStartInfo *>(packet_type()) : nullptr;
  }
  const CheckPassword *packet_type_as_CheckPassword() const {
    return packet_type_type() == Type_CheckPassword ? static_cast<const CheckPassword *>(packet_type()) : nullptr;
  }
  const ChatMessage *packet_type_as_ChatMessage() const {
    return packet_type_type() == Type_ChatMessage ? static_cast<const ChatMessage *>(packet_type()) : nullptr;
  }
  const AttackInfo *packet_type_as_AttackInfo() const {
    return packet_type_type() == Type_AttackInfo ? static_cast<const AttackInfo *>(packet_type()) : nullptr;
  }
  const PlayerData *packet_type_as_PlayerData() const {
    return packet_type_type() == Type_PlayerData ? static_cast<const PlayerData *>(packet_type()) : nullptr;
  }
  const GameResult *packet_type_as_GameResult() const {
    return packet_type_type() == Type_GameResult ? static_cast<const GameResult *>(packet_type()) : nullptr;
  }
  const TopRanking *packet_type_as_TopRanking() const {
    return packet_type_type() == Type_TopRanking ? static_cast<const TopRanking *>(packet_type()) : nullptr;
  }
  const MonsterData *packet_type_as_MonsterData() const {
    return packet_type_type() == Type_MonsterData ? static_cast<const MonsterData *>(packet_type()) : nullptr;
  }
  const SystemMessage *packet_type_as_SystemMessage() const {
    return packet_type_type() == Type_SystemMessage ? static_cast<const SystemMessage *>(packet_type()) : nullptr;
  }
  const SystemTime *packet_type_as_SystemTime() const {
    return packet_type_type() == Type_SystemTime ? static_cast<const SystemTime *>(packet_type()) : nullptr;
  }
  const SpawnOK *packet_type_as_SpawnOK() const {
    return packet_type_type() == Type_SpawnOK ? static_cast<const SpawnOK *>(packet_type()) : nullptr;
  }
  const MoveMonster *packet_type_as_MoveMonster() const {
    return packet_type_type() == Type_MoveMonster ? static_cast<const MoveMonster *>(packet_type()) : nullptr;
  }
  const MoveOK *packet_type_as_MoveOK() const {
    return packet_type_type() == Type_MoveOK ? static_cast<const MoveOK *>(packet_type()) : nullptr;
  }
  const SpawnMonsterData *packet_type_as_SpawnMonsterData() const {
    return packet_type_type() == Type_SpawnMonsterData ? static_cast<const SpawnMonsterData *>(packet_type()) : nullptr;
  }
  const MyData *packet_type_as_MyData() const {
    return packet_type_type() == Type_MyData ? static_cast<const MyData *>(packet_type()) : nullptr;
  }
  const Revival *packet_type_as_Revival() const {
    return packet_type_type() == Type_Revival ? static_cast<const Revival *>(packet_type()) : nullptr;
  }
  const GameEnd *packet_type_as_GameEnd() const {
    return packet_type_type() == Type_GameEnd ? static_cast<const GameEnd *>(packet_type()) : nullptr;
  }
  const ItemUsing *packet_type_as_ItemUsing() const {
    return packet_type_type() == Type_ItemUsing ? static_cast<const ItemUsing *>(packet_type()) : nullptr;
  }
  const RefreshItem *packet_type_as_RefreshItem() const {
    return packet_type_type() == Type_RefreshItem ? static_cast<const RefreshItem *>(packet_type()) : nullptr;
  }
  const ItemBuy *packet_type_as_ItemBuy() const {
    return packet_type_type() == Type_ItemBuy ? static_cast<const ItemBuy *>(packet_type()) : nullptr;
  }
  const BuyRequest *packet_type_as_BuyRequest() const {
    return packet_type_type() == Type_BuyRequest ? static_cast<const BuyRequest *>(packet_type()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_PACKET_TYPE) &&
           VerifyType(verifier, packet_type(), packet_type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const LoginData *Packet::packet_type_as<LoginData>() const {
  return packet_type_as_LoginData();
}

template<> inline const SignUpData *Packet::packet_type_as<SignUpData>() const {
  return packet_type_as_SignUpData();
}

template<> inline const GameState *Packet::packet_type_as<GameState>() const {
  return packet_type_as_GameState();
}

template<> inline const AllUser *Packet::packet_type_as<AllUser>() const {
  return packet_type_as_AllUser();
}

template<> inline const RoomInfo *Packet::packet_type_as<RoomInfo>() const {
  return packet_type_as_RoomInfo();
}

template<> inline const RoomList *Packet::packet_type_as<RoomList>() const {
  return packet_type_as_RoomList();
}

template<> inline const GameReadyInfo *Packet::packet_type_as<GameReadyInfo>() const {
  return packet_type_as_GameReadyInfo();
}

template<> inline const LeaveRoom *Packet::packet_type_as<LeaveRoom>() const {
  return packet_type_as_LeaveRoom();
}

template<> inline const GameStartInfo *Packet::packet_type_as<GameStartInfo>() const {
  return packet_type_as_GameStartInfo();
}

template<> inline const CheckPassword *Packet::packet_type_as<CheckPassword>() const {
  return packet_type_as_CheckPassword();
}

template<> inline const ChatMessage *Packet::packet_type_as<ChatMessage>() const {
  return packet_type_as_ChatMessage();
}

template<> inline const AttackInfo *Packet::packet_type_as<AttackInfo>() const {
  return packet_type_as_AttackInfo();
}

template<> inline const PlayerData *Packet::packet_type_as<PlayerData>() const {
  return packet_type_as_PlayerData();
}

template<> inline const GameResult *Packet::packet_type_as<GameResult>() const {
  return packet_type_as_GameResult();
}

template<> inline const TopRanking *Packet::packet_type_as<TopRanking>() const {
  return packet_type_as_TopRanking();
}

template<> inline const MonsterData *Packet::packet_type_as<MonsterData>() const {
  return packet_type_as_MonsterData();
}

template<> inline const SystemMessage *Packet::packet_type_as<SystemMessage>() const {
  return packet_type_as_SystemMessage();
}

template<> inline const SystemTime *Packet::packet_type_as<SystemTime>() const {
  return packet_type_as_SystemTime();
}

template<> inline const SpawnOK *Packet::packet_type_as<SpawnOK>() const {
  return packet_type_as_SpawnOK();
}

template<> inline const MoveMonster *Packet::packet_type_as<MoveMonster>() const {
  return packet_type_as_MoveMonster();
}

template<> inline const MoveOK *Packet::packet_type_as<MoveOK>() const {
  return packet_type_as_MoveOK();
}

template<> inline const SpawnMonsterData *Packet::packet_type_as<SpawnMonsterData>() const {
  return packet_type_as_SpawnMonsterData();
}

template<> inline const MyData *Packet::packet_type_as<MyData>() const {
  return packet_type_as_MyData();
}

template<> inline const Revival *Packet::packet_type_as<Revival>() const {
  return packet_type_as_Revival();
}

template<> inline const GameEnd *Packet::packet_type_as<GameEnd>() const {
  return packet_type_as_GameEnd();
}

template<> inline const ItemUsing *Packet::packet_type_as<ItemUsing>() const {
  return packet_type_as_ItemUsing();
}

template<> inline const RefreshItem *Packet::packet_type_as<RefreshItem>() const {
  return packet_type_as_RefreshItem();
}

template<> inline const ItemBuy *Packet::packet_type_as<ItemBuy>() const {
  return packet_type_as_ItemBuy();
}

template<> inline const BuyRequest *Packet::packet_type_as<BuyRequest>() const {
  return packet_type_as_BuyRequest();
}

struct PacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packet_type_type(Type packet_type_type) {
    fbb_.AddElement<uint8_t>(Packet::VT_PACKET_TYPE_TYPE, static_cast<uint8_t>(packet_type_type), 0);
  }
  void add_packet_type(flatbuffers::Offset<void> packet_type) {
    fbb_.AddOffset(Packet::VT_PACKET_TYPE, packet_type);
  }
  explicit PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PacketBuilder &operator=(const PacketBuilder &);
  flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type packet_type_type = Type_NONE,
    flatbuffers::Offset<void> packet_type = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_packet_type(packet_type);
  builder_.add_packet_type_type(packet_type_type);
  return builder_.Finish();
}

struct LoginData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_PASSWORD = 6,
    VT_ISLOGINOK = 8,
    VT_IDCODE = 10,
    VT_POTION100 = 12,
    VT_POTION50 = 14,
    VT_GOLD = 16
  };
  const flatbuffers::String *ID() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *Password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool IsLoginOk() const {
    return GetField<uint8_t>(VT_ISLOGINOK, 0) != 0;
  }
  int32_t IDCode() const {
    return GetField<int32_t>(VT_IDCODE, 0);
  }
  int32_t Potion100() const {
    return GetField<int32_t>(VT_POTION100, 0);
  }
  int32_t Potion50() const {
    return GetField<int32_t>(VT_POTION50, 0);
  }
  int32_t Gold() const {
    return GetField<int32_t>(VT_GOLD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(Password()) &&
           VerifyField<uint8_t>(verifier, VT_ISLOGINOK) &&
           VerifyField<int32_t>(verifier, VT_IDCODE) &&
           VerifyField<int32_t>(verifier, VT_POTION100) &&
           VerifyField<int32_t>(verifier, VT_POTION50) &&
           VerifyField<int32_t>(verifier, VT_GOLD) &&
           verifier.EndTable();
  }
};

struct LoginDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(flatbuffers::Offset<flatbuffers::String> ID) {
    fbb_.AddOffset(LoginData::VT_ID, ID);
  }
  void add_Password(flatbuffers::Offset<flatbuffers::String> Password) {
    fbb_.AddOffset(LoginData::VT_PASSWORD, Password);
  }
  void add_IsLoginOk(bool IsLoginOk) {
    fbb_.AddElement<uint8_t>(LoginData::VT_ISLOGINOK, static_cast<uint8_t>(IsLoginOk), 0);
  }
  void add_IDCode(int32_t IDCode) {
    fbb_.AddElement<int32_t>(LoginData::VT_IDCODE, IDCode, 0);
  }
  void add_Potion100(int32_t Potion100) {
    fbb_.AddElement<int32_t>(LoginData::VT_POTION100, Potion100, 0);
  }
  void add_Potion50(int32_t Potion50) {
    fbb_.AddElement<int32_t>(LoginData::VT_POTION50, Potion50, 0);
  }
  void add_Gold(int32_t Gold) {
    fbb_.AddElement<int32_t>(LoginData::VT_GOLD, Gold, 0);
  }
  explicit LoginDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginDataBuilder &operator=(const LoginDataBuilder &);
  flatbuffers::Offset<LoginData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoginData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoginData> CreateLoginData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ID = 0,
    flatbuffers::Offset<flatbuffers::String> Password = 0,
    bool IsLoginOk = false,
    int32_t IDCode = 0,
    int32_t Potion100 = 0,
    int32_t Potion50 = 0,
    int32_t Gold = 0) {
  LoginDataBuilder builder_(_fbb);
  builder_.add_Gold(Gold);
  builder_.add_Potion50(Potion50);
  builder_.add_Potion100(Potion100);
  builder_.add_IDCode(IDCode);
  builder_.add_Password(Password);
  builder_.add_ID(ID);
  builder_.add_IsLoginOk(IsLoginOk);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoginData> CreateLoginDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *Password = nullptr,
    bool IsLoginOk = false,
    int32_t IDCode = 0,
    int32_t Potion100 = 0,
    int32_t Potion50 = 0,
    int32_t Gold = 0) {
  return object::CreateLoginData(
      _fbb,
      ID ? _fbb.CreateString(ID) : 0,
      Password ? _fbb.CreateString(Password) : 0,
      IsLoginOk,
      IDCode,
      Potion100,
      Potion50,
      Gold);
}

struct SignUpData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_PASSWORD = 6,
    VT_ISSIGNUPPOSSIBLE = 8
  };
  const flatbuffers::String *ID() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *Password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool IsSignUpPossible() const {
    return GetField<uint8_t>(VT_ISSIGNUPPOSSIBLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(Password()) &&
           VerifyField<uint8_t>(verifier, VT_ISSIGNUPPOSSIBLE) &&
           verifier.EndTable();
  }
};

struct SignUpDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(flatbuffers::Offset<flatbuffers::String> ID) {
    fbb_.AddOffset(SignUpData::VT_ID, ID);
  }
  void add_Password(flatbuffers::Offset<flatbuffers::String> Password) {
    fbb_.AddOffset(SignUpData::VT_PASSWORD, Password);
  }
  void add_IsSignUpPossible(bool IsSignUpPossible) {
    fbb_.AddElement<uint8_t>(SignUpData::VT_ISSIGNUPPOSSIBLE, static_cast<uint8_t>(IsSignUpPossible), 0);
  }
  explicit SignUpDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignUpDataBuilder &operator=(const SignUpDataBuilder &);
  flatbuffers::Offset<SignUpData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignUpData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignUpData> CreateSignUpData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ID = 0,
    flatbuffers::Offset<flatbuffers::String> Password = 0,
    bool IsSignUpPossible = false) {
  SignUpDataBuilder builder_(_fbb);
  builder_.add_Password(Password);
  builder_.add_ID(ID);
  builder_.add_IsSignUpPossible(IsSignUpPossible);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignUpData> CreateSignUpDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *Password = nullptr,
    bool IsSignUpPossible = false) {
  return object::CreateSignUpData(
      _fbb,
      ID ? _fbb.CreateString(ID) : 0,
      Password ? _fbb.CreateString(Password) : 0,
      IsSignUpPossible);
}

struct GameState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE = 4,
    VT_USERIDCODE = 6,
    VT_MAXPOINT = 8,
    VT_USERID = 10
  };
  int32_t Code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  int32_t UserIDCode() const {
    return GetField<int32_t>(VT_USERIDCODE, 0);
  }
  int32_t MaxPoint() const {
    return GetField<int32_t>(VT_MAXPOINT, 0);
  }
  const flatbuffers::String *UserID() const {
    return GetPointer<const flatbuffers::String *>(VT_USERID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           VerifyField<int32_t>(verifier, VT_USERIDCODE) &&
           VerifyField<int32_t>(verifier, VT_MAXPOINT) &&
           VerifyOffset(verifier, VT_USERID) &&
           verifier.VerifyString(UserID()) &&
           verifier.EndTable();
  }
};

struct GameStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Code(int32_t Code) {
    fbb_.AddElement<int32_t>(GameState::VT_CODE, Code, 0);
  }
  void add_UserIDCode(int32_t UserIDCode) {
    fbb_.AddElement<int32_t>(GameState::VT_USERIDCODE, UserIDCode, 0);
  }
  void add_MaxPoint(int32_t MaxPoint) {
    fbb_.AddElement<int32_t>(GameState::VT_MAXPOINT, MaxPoint, 0);
  }
  void add_UserID(flatbuffers::Offset<flatbuffers::String> UserID) {
    fbb_.AddOffset(GameState::VT_USERID, UserID);
  }
  explicit GameStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameStateBuilder &operator=(const GameStateBuilder &);
  flatbuffers::Offset<GameState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameState>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameState> CreateGameState(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Code = 0,
    int32_t UserIDCode = 0,
    int32_t MaxPoint = 0,
    flatbuffers::Offset<flatbuffers::String> UserID = 0) {
  GameStateBuilder builder_(_fbb);
  builder_.add_UserID(UserID);
  builder_.add_MaxPoint(MaxPoint);
  builder_.add_UserIDCode(UserIDCode);
  builder_.add_Code(Code);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameState> CreateGameStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Code = 0,
    int32_t UserIDCode = 0,
    int32_t MaxPoint = 0,
    const char *UserID = nullptr) {
  return object::CreateGameState(
      _fbb,
      Code,
      UserIDCode,
      MaxPoint,
      UserID ? _fbb.CreateString(UserID) : 0);
}

struct AllUser FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALLLIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<UserInfo>> *AllList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserInfo>> *>(VT_ALLLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ALLLIST) &&
           verifier.VerifyVector(AllList()) &&
           verifier.VerifyVectorOfTables(AllList()) &&
           verifier.EndTable();
  }
};

struct AllUserBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AllList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserInfo>>> AllList) {
    fbb_.AddOffset(AllUser::VT_ALLLIST, AllList);
  }
  explicit AllUserBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllUserBuilder &operator=(const AllUserBuilder &);
  flatbuffers::Offset<AllUser> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllUser>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllUser> CreateAllUser(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserInfo>>> AllList = 0) {
  AllUserBuilder builder_(_fbb);
  builder_.add_AllList(AllList);
  return builder_.Finish();
}

inline flatbuffers::Offset<AllUser> CreateAllUserDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<UserInfo>> *AllList = nullptr) {
  return object::CreateAllUser(
      _fbb,
      AllList ? _fbb.CreateVector<flatbuffers::Offset<UserInfo>>(*AllList) : 0);
}

struct UserInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_IDCODE = 6,
    VT_CODE = 8,
    VT_MAXPOINT = 10
  };
  const flatbuffers::String *ID() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int32_t IDCode() const {
    return GetField<int32_t>(VT_IDCODE, 0);
  }
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  int32_t MaxPoint() const {
    return GetField<int32_t>(VT_MAXPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyField<int32_t>(verifier, VT_IDCODE) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           VerifyField<int32_t>(verifier, VT_MAXPOINT) &&
           verifier.EndTable();
  }
};

struct UserInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(flatbuffers::Offset<flatbuffers::String> ID) {
    fbb_.AddOffset(UserInfo::VT_ID, ID);
  }
  void add_IDCode(int32_t IDCode) {
    fbb_.AddElement<int32_t>(UserInfo::VT_IDCODE, IDCode, 0);
  }
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(UserInfo::VT_CODE, code, 0);
  }
  void add_MaxPoint(int32_t MaxPoint) {
    fbb_.AddElement<int32_t>(UserInfo::VT_MAXPOINT, MaxPoint, 0);
  }
  explicit UserInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserInfoBuilder &operator=(const UserInfoBuilder &);
  flatbuffers::Offset<UserInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserInfo> CreateUserInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ID = 0,
    int32_t IDCode = 0,
    int32_t code = 0,
    int32_t MaxPoint = 0) {
  UserInfoBuilder builder_(_fbb);
  builder_.add_MaxPoint(MaxPoint);
  builder_.add_code(code);
  builder_.add_IDCode(IDCode);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserInfo> CreateUserInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    int32_t IDCode = 0,
    int32_t code = 0,
    int32_t MaxPoint = 0) {
  return object::CreateUserInfo(
      _fbb,
      ID ? _fbb.CreateString(ID) : 0,
      IDCode,
      code,
      MaxPoint);
}

struct RoomList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROOM_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<RoomInfo>> *room_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RoomInfo>> *>(VT_ROOM_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOM_LIST) &&
           verifier.VerifyVector(room_list()) &&
           verifier.VerifyVectorOfTables(room_list()) &&
           verifier.EndTable();
  }
};

struct RoomListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_room_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RoomInfo>>> room_list) {
    fbb_.AddOffset(RoomList::VT_ROOM_LIST, room_list);
  }
  explicit RoomListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RoomListBuilder &operator=(const RoomListBuilder &);
  flatbuffers::Offset<RoomList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoomList>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoomList> CreateRoomList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RoomInfo>>> room_list = 0) {
  RoomListBuilder builder_(_fbb);
  builder_.add_room_list(room_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoomList> CreateRoomListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<RoomInfo>> *room_list = nullptr) {
  return object::CreateRoomList(
      _fbb,
      room_list ? _fbb.CreateVector<flatbuffers::Offset<RoomInfo>>(*room_list) : 0);
}

struct RoomInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROOMNAME = 4,
    VT_ROOMNUMBER = 6,
    VT_MAXUSERNUMBER = 8,
    VT_CURRENTUSERNUMBER = 10,
    VT_PASSWORD = 12,
    VT_ROOMOWNER = 14,
    VT_ISTHISROOMPLAYINGGAME = 16,
    VT_USER_LIST = 18,
    VT_FOUNTAINHEALTH = 20,
    VT_ISTHISROOMLOCK = 22
  };
  const flatbuffers::String *RoomName() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMNAME);
  }
  int32_t RoomNumber() const {
    return GetField<int32_t>(VT_ROOMNUMBER, 0);
  }
  int32_t MaxUserNumber() const {
    return GetField<int32_t>(VT_MAXUSERNUMBER, 0);
  }
  int32_t CurrentUserNumber() const {
    return GetField<int32_t>(VT_CURRENTUSERNUMBER, 0);
  }
  const flatbuffers::String *Password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  int32_t RoomOwner() const {
    return GetField<int32_t>(VT_ROOMOWNER, 0);
  }
  bool IsThisRoomPlayingGame() const {
    return GetField<uint8_t>(VT_ISTHISROOMPLAYINGGAME, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<RoomUserInfo>> *user_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RoomUserInfo>> *>(VT_USER_LIST);
  }
  int32_t FountainHealth() const {
    return GetField<int32_t>(VT_FOUNTAINHEALTH, 0);
  }
  bool IsThisRoomLock() const {
    return GetField<uint8_t>(VT_ISTHISROOMLOCK, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOMNAME) &&
           verifier.VerifyString(RoomName()) &&
           VerifyField<int32_t>(verifier, VT_ROOMNUMBER) &&
           VerifyField<int32_t>(verifier, VT_MAXUSERNUMBER) &&
           VerifyField<int32_t>(verifier, VT_CURRENTUSERNUMBER) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(Password()) &&
           VerifyField<int32_t>(verifier, VT_ROOMOWNER) &&
           VerifyField<uint8_t>(verifier, VT_ISTHISROOMPLAYINGGAME) &&
           VerifyOffset(verifier, VT_USER_LIST) &&
           verifier.VerifyVector(user_list()) &&
           verifier.VerifyVectorOfTables(user_list()) &&
           VerifyField<int32_t>(verifier, VT_FOUNTAINHEALTH) &&
           VerifyField<uint8_t>(verifier, VT_ISTHISROOMLOCK) &&
           verifier.EndTable();
  }
};

struct RoomInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RoomName(flatbuffers::Offset<flatbuffers::String> RoomName) {
    fbb_.AddOffset(RoomInfo::VT_ROOMNAME, RoomName);
  }
  void add_RoomNumber(int32_t RoomNumber) {
    fbb_.AddElement<int32_t>(RoomInfo::VT_ROOMNUMBER, RoomNumber, 0);
  }
  void add_MaxUserNumber(int32_t MaxUserNumber) {
    fbb_.AddElement<int32_t>(RoomInfo::VT_MAXUSERNUMBER, MaxUserNumber, 0);
  }
  void add_CurrentUserNumber(int32_t CurrentUserNumber) {
    fbb_.AddElement<int32_t>(RoomInfo::VT_CURRENTUSERNUMBER, CurrentUserNumber, 0);
  }
  void add_Password(flatbuffers::Offset<flatbuffers::String> Password) {
    fbb_.AddOffset(RoomInfo::VT_PASSWORD, Password);
  }
  void add_RoomOwner(int32_t RoomOwner) {
    fbb_.AddElement<int32_t>(RoomInfo::VT_ROOMOWNER, RoomOwner, 0);
  }
  void add_IsThisRoomPlayingGame(bool IsThisRoomPlayingGame) {
    fbb_.AddElement<uint8_t>(RoomInfo::VT_ISTHISROOMPLAYINGGAME, static_cast<uint8_t>(IsThisRoomPlayingGame), 0);
  }
  void add_user_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RoomUserInfo>>> user_list) {
    fbb_.AddOffset(RoomInfo::VT_USER_LIST, user_list);
  }
  void add_FountainHealth(int32_t FountainHealth) {
    fbb_.AddElement<int32_t>(RoomInfo::VT_FOUNTAINHEALTH, FountainHealth, 0);
  }
  void add_IsThisRoomLock(bool IsThisRoomLock) {
    fbb_.AddElement<uint8_t>(RoomInfo::VT_ISTHISROOMLOCK, static_cast<uint8_t>(IsThisRoomLock), 0);
  }
  explicit RoomInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RoomInfoBuilder &operator=(const RoomInfoBuilder &);
  flatbuffers::Offset<RoomInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoomInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoomInfo> CreateRoomInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> RoomName = 0,
    int32_t RoomNumber = 0,
    int32_t MaxUserNumber = 0,
    int32_t CurrentUserNumber = 0,
    flatbuffers::Offset<flatbuffers::String> Password = 0,
    int32_t RoomOwner = 0,
    bool IsThisRoomPlayingGame = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RoomUserInfo>>> user_list = 0,
    int32_t FountainHealth = 0,
    bool IsThisRoomLock = false) {
  RoomInfoBuilder builder_(_fbb);
  builder_.add_FountainHealth(FountainHealth);
  builder_.add_user_list(user_list);
  builder_.add_RoomOwner(RoomOwner);
  builder_.add_Password(Password);
  builder_.add_CurrentUserNumber(CurrentUserNumber);
  builder_.add_MaxUserNumber(MaxUserNumber);
  builder_.add_RoomNumber(RoomNumber);
  builder_.add_RoomName(RoomName);
  builder_.add_IsThisRoomLock(IsThisRoomLock);
  builder_.add_IsThisRoomPlayingGame(IsThisRoomPlayingGame);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoomInfo> CreateRoomInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *RoomName = nullptr,
    int32_t RoomNumber = 0,
    int32_t MaxUserNumber = 0,
    int32_t CurrentUserNumber = 0,
    const char *Password = nullptr,
    int32_t RoomOwner = 0,
    bool IsThisRoomPlayingGame = false,
    const std::vector<flatbuffers::Offset<RoomUserInfo>> *user_list = nullptr,
    int32_t FountainHealth = 0,
    bool IsThisRoomLock = false) {
  return object::CreateRoomInfo(
      _fbb,
      RoomName ? _fbb.CreateString(RoomName) : 0,
      RoomNumber,
      MaxUserNumber,
      CurrentUserNumber,
      Password ? _fbb.CreateString(Password) : 0,
      RoomOwner,
      IsThisRoomPlayingGame,
      user_list ? _fbb.CreateVector<flatbuffers::Offset<RoomUserInfo>>(*user_list) : 0,
      FountainHealth,
      IsThisRoomLock);
}

struct RoomUserInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USERID = 4,
    VT_USERIDCODE = 6,
    VT_ISREADY = 8,
    VT_MAXPOINT = 10
  };
  const flatbuffers::String *userid() const {
    return GetPointer<const flatbuffers::String *>(VT_USERID);
  }
  int32_t useridCode() const {
    return GetField<int32_t>(VT_USERIDCODE, 0);
  }
  bool isready() const {
    return GetField<uint8_t>(VT_ISREADY, 0) != 0;
  }
  int32_t MaxPoint() const {
    return GetField<int32_t>(VT_MAXPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USERID) &&
           verifier.VerifyString(userid()) &&
           VerifyField<int32_t>(verifier, VT_USERIDCODE) &&
           VerifyField<uint8_t>(verifier, VT_ISREADY) &&
           VerifyField<int32_t>(verifier, VT_MAXPOINT) &&
           verifier.EndTable();
  }
};

struct RoomUserInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_userid(flatbuffers::Offset<flatbuffers::String> userid) {
    fbb_.AddOffset(RoomUserInfo::VT_USERID, userid);
  }
  void add_useridCode(int32_t useridCode) {
    fbb_.AddElement<int32_t>(RoomUserInfo::VT_USERIDCODE, useridCode, 0);
  }
  void add_isready(bool isready) {
    fbb_.AddElement<uint8_t>(RoomUserInfo::VT_ISREADY, static_cast<uint8_t>(isready), 0);
  }
  void add_MaxPoint(int32_t MaxPoint) {
    fbb_.AddElement<int32_t>(RoomUserInfo::VT_MAXPOINT, MaxPoint, 0);
  }
  explicit RoomUserInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RoomUserInfoBuilder &operator=(const RoomUserInfoBuilder &);
  flatbuffers::Offset<RoomUserInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoomUserInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoomUserInfo> CreateRoomUserInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> userid = 0,
    int32_t useridCode = 0,
    bool isready = false,
    int32_t MaxPoint = 0) {
  RoomUserInfoBuilder builder_(_fbb);
  builder_.add_MaxPoint(MaxPoint);
  builder_.add_useridCode(useridCode);
  builder_.add_userid(userid);
  builder_.add_isready(isready);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoomUserInfo> CreateRoomUserInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *userid = nullptr,
    int32_t useridCode = 0,
    bool isready = false,
    int32_t MaxPoint = 0) {
  return object::CreateRoomUserInfo(
      _fbb,
      userid ? _fbb.CreateString(userid) : 0,
      useridCode,
      isready,
      MaxPoint);
}

struct GameReadyInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_READYUSERID = 4,
    VT_READY = 6,
    VT_READYROOMNUMBER = 8
  };
  int32_t ReadyUserId() const {
    return GetField<int32_t>(VT_READYUSERID, 0);
  }
  bool ready() const {
    return GetField<uint8_t>(VT_READY, 0) != 0;
  }
  int32_t ReadyRoomnumber() const {
    return GetField<int32_t>(VT_READYROOMNUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_READYUSERID) &&
           VerifyField<uint8_t>(verifier, VT_READY) &&
           VerifyField<int32_t>(verifier, VT_READYROOMNUMBER) &&
           verifier.EndTable();
  }
};

struct GameReadyInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ReadyUserId(int32_t ReadyUserId) {
    fbb_.AddElement<int32_t>(GameReadyInfo::VT_READYUSERID, ReadyUserId, 0);
  }
  void add_ready(bool ready) {
    fbb_.AddElement<uint8_t>(GameReadyInfo::VT_READY, static_cast<uint8_t>(ready), 0);
  }
  void add_ReadyRoomnumber(int32_t ReadyRoomnumber) {
    fbb_.AddElement<int32_t>(GameReadyInfo::VT_READYROOMNUMBER, ReadyRoomnumber, 0);
  }
  explicit GameReadyInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameReadyInfoBuilder &operator=(const GameReadyInfoBuilder &);
  flatbuffers::Offset<GameReadyInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameReadyInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameReadyInfo> CreateGameReadyInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ReadyUserId = 0,
    bool ready = false,
    int32_t ReadyRoomnumber = 0) {
  GameReadyInfoBuilder builder_(_fbb);
  builder_.add_ReadyRoomnumber(ReadyRoomnumber);
  builder_.add_ReadyUserId(ReadyUserId);
  builder_.add_ready(ready);
  return builder_.Finish();
}

struct LeaveRoom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LEAVEUSERID = 4,
    VT_LEAVEROOMNUMBER = 6
  };
  int32_t LeaveUserID() const {
    return GetField<int32_t>(VT_LEAVEUSERID, 0);
  }
  int32_t LeaveRoomnumber() const {
    return GetField<int32_t>(VT_LEAVEROOMNUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEAVEUSERID) &&
           VerifyField<int32_t>(verifier, VT_LEAVEROOMNUMBER) &&
           verifier.EndTable();
  }
};

struct LeaveRoomBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_LeaveUserID(int32_t LeaveUserID) {
    fbb_.AddElement<int32_t>(LeaveRoom::VT_LEAVEUSERID, LeaveUserID, 0);
  }
  void add_LeaveRoomnumber(int32_t LeaveRoomnumber) {
    fbb_.AddElement<int32_t>(LeaveRoom::VT_LEAVEROOMNUMBER, LeaveRoomnumber, 0);
  }
  explicit LeaveRoomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeaveRoomBuilder &operator=(const LeaveRoomBuilder &);
  flatbuffers::Offset<LeaveRoom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeaveRoom>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeaveRoom> CreateLeaveRoom(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t LeaveUserID = 0,
    int32_t LeaveRoomnumber = 0) {
  LeaveRoomBuilder builder_(_fbb);
  builder_.add_LeaveRoomnumber(LeaveRoomnumber);
  builder_.add_LeaveUserID(LeaveUserID);
  return builder_.Finish();
}

struct GameStartInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STARTGAMEROOMNUMBER = 4,
    VT_ISSTART = 6,
    VT_ISLOADINGCOMPLETE = 8,
    VT_COUNT = 10,
    VT_ISCOUNTING = 12
  };
  int32_t StartGameRoomnumber() const {
    return GetField<int32_t>(VT_STARTGAMEROOMNUMBER, 0);
  }
  bool isstart() const {
    return GetField<uint8_t>(VT_ISSTART, 0) != 0;
  }
  bool isloadingcomplete() const {
    return GetField<uint8_t>(VT_ISLOADINGCOMPLETE, 0) != 0;
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool iscounting() const {
    return GetField<uint8_t>(VT_ISCOUNTING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STARTGAMEROOMNUMBER) &&
           VerifyField<uint8_t>(verifier, VT_ISSTART) &&
           VerifyField<uint8_t>(verifier, VT_ISLOADINGCOMPLETE) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           VerifyField<uint8_t>(verifier, VT_ISCOUNTING) &&
           verifier.EndTable();
  }
};

struct GameStartInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_StartGameRoomnumber(int32_t StartGameRoomnumber) {
    fbb_.AddElement<int32_t>(GameStartInfo::VT_STARTGAMEROOMNUMBER, StartGameRoomnumber, 0);
  }
  void add_isstart(bool isstart) {
    fbb_.AddElement<uint8_t>(GameStartInfo::VT_ISSTART, static_cast<uint8_t>(isstart), 0);
  }
  void add_isloadingcomplete(bool isloadingcomplete) {
    fbb_.AddElement<uint8_t>(GameStartInfo::VT_ISLOADINGCOMPLETE, static_cast<uint8_t>(isloadingcomplete), 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(GameStartInfo::VT_COUNT, count, 0);
  }
  void add_iscounting(bool iscounting) {
    fbb_.AddElement<uint8_t>(GameStartInfo::VT_ISCOUNTING, static_cast<uint8_t>(iscounting), 0);
  }
  explicit GameStartInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameStartInfoBuilder &operator=(const GameStartInfoBuilder &);
  flatbuffers::Offset<GameStartInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameStartInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameStartInfo> CreateGameStartInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t StartGameRoomnumber = 0,
    bool isstart = false,
    bool isloadingcomplete = false,
    int32_t count = 0,
    bool iscounting = false) {
  GameStartInfoBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_StartGameRoomnumber(StartGameRoomnumber);
  builder_.add_iscounting(iscounting);
  builder_.add_isloadingcomplete(isloadingcomplete);
  builder_.add_isstart(isstart);
  return builder_.Finish();
}

struct CheckPassword FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PASSWORD = 4,
    VT_ISCORRECT = 6,
    VT_ROOMNUMBER = 8
  };
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Iscorrect() const {
    return GetField<uint8_t>(VT_ISCORRECT, 0) != 0;
  }
  int32_t roomnumber() const {
    return GetField<int32_t>(VT_ROOMNUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           VerifyField<uint8_t>(verifier, VT_ISCORRECT) &&
           VerifyField<int32_t>(verifier, VT_ROOMNUMBER) &&
           verifier.EndTable();
  }
};

struct CheckPasswordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(CheckPassword::VT_PASSWORD, password);
  }
  void add_Iscorrect(bool Iscorrect) {
    fbb_.AddElement<uint8_t>(CheckPassword::VT_ISCORRECT, static_cast<uint8_t>(Iscorrect), 0);
  }
  void add_roomnumber(int32_t roomnumber) {
    fbb_.AddElement<int32_t>(CheckPassword::VT_ROOMNUMBER, roomnumber, 0);
  }
  explicit CheckPasswordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CheckPasswordBuilder &operator=(const CheckPasswordBuilder &);
  flatbuffers::Offset<CheckPassword> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CheckPassword>(end);
    return o;
  }
};

inline flatbuffers::Offset<CheckPassword> CreateCheckPassword(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> password = 0,
    bool Iscorrect = false,
    int32_t roomnumber = 0) {
  CheckPasswordBuilder builder_(_fbb);
  builder_.add_roomnumber(roomnumber);
  builder_.add_password(password);
  builder_.add_Iscorrect(Iscorrect);
  return builder_.Finish();
}

inline flatbuffers::Offset<CheckPassword> CreateCheckPasswordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *password = nullptr,
    bool Iscorrect = false,
    int32_t roomnumber = 0) {
  return object::CreateCheckPassword(
      _fbb,
      password ? _fbb.CreateString(password) : 0,
      Iscorrect,
      roomnumber);
}

struct ChatMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SENDERID = 4,
    VT_CHATMSG = 6,
    VT_GAMESTATE = 8
  };
  const flatbuffers::String *SenderID() const {
    return GetPointer<const flatbuffers::String *>(VT_SENDERID);
  }
  const flatbuffers::String *ChatMsg() const {
    return GetPointer<const flatbuffers::String *>(VT_CHATMSG);
  }
  int32_t GameState() const {
    return GetField<int32_t>(VT_GAMESTATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SENDERID) &&
           verifier.VerifyString(SenderID()) &&
           VerifyOffset(verifier, VT_CHATMSG) &&
           verifier.VerifyString(ChatMsg()) &&
           VerifyField<int32_t>(verifier, VT_GAMESTATE) &&
           verifier.EndTable();
  }
};

struct ChatMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SenderID(flatbuffers::Offset<flatbuffers::String> SenderID) {
    fbb_.AddOffset(ChatMessage::VT_SENDERID, SenderID);
  }
  void add_ChatMsg(flatbuffers::Offset<flatbuffers::String> ChatMsg) {
    fbb_.AddOffset(ChatMessage::VT_CHATMSG, ChatMsg);
  }
  void add_GameState(int32_t GameState) {
    fbb_.AddElement<int32_t>(ChatMessage::VT_GAMESTATE, GameState, 0);
  }
  explicit ChatMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChatMessageBuilder &operator=(const ChatMessageBuilder &);
  flatbuffers::Offset<ChatMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChatMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChatMessage> CreateChatMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> SenderID = 0,
    flatbuffers::Offset<flatbuffers::String> ChatMsg = 0,
    int32_t GameState = 0) {
  ChatMessageBuilder builder_(_fbb);
  builder_.add_GameState(GameState);
  builder_.add_ChatMsg(ChatMsg);
  builder_.add_SenderID(SenderID);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChatMessage> CreateChatMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *SenderID = nullptr,
    const char *ChatMsg = nullptr,
    int32_t GameState = 0) {
  return object::CreateChatMessage(
      _fbb,
      SenderID ? _fbb.CreateString(SenderID) : 0,
      ChatMsg ? _fbb.CreateString(ChatMsg) : 0,
      GameState);
}

struct AttackInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTACKERID = 4,
    VT_TARGETID = 6,
    VT_ATTACKTYPE = 8
  };
  int32_t AttackerID() const {
    return GetField<int32_t>(VT_ATTACKERID, 0);
  }
  int32_t TargetID() const {
    return GetField<int32_t>(VT_TARGETID, 0);
  }
  int32_t AttackType() const {
    return GetField<int32_t>(VT_ATTACKTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ATTACKERID) &&
           VerifyField<int32_t>(verifier, VT_TARGETID) &&
           VerifyField<int32_t>(verifier, VT_ATTACKTYPE) &&
           verifier.EndTable();
  }
};

struct AttackInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AttackerID(int32_t AttackerID) {
    fbb_.AddElement<int32_t>(AttackInfo::VT_ATTACKERID, AttackerID, 0);
  }
  void add_TargetID(int32_t TargetID) {
    fbb_.AddElement<int32_t>(AttackInfo::VT_TARGETID, TargetID, 0);
  }
  void add_AttackType(int32_t AttackType) {
    fbb_.AddElement<int32_t>(AttackInfo::VT_ATTACKTYPE, AttackType, 0);
  }
  explicit AttackInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttackInfoBuilder &operator=(const AttackInfoBuilder &);
  flatbuffers::Offset<AttackInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttackInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttackInfo> CreateAttackInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t AttackerID = 0,
    int32_t TargetID = 0,
    int32_t AttackType = 0) {
  AttackInfoBuilder builder_(_fbb);
  builder_.add_AttackType(AttackType);
  builder_.add_TargetID(TargetID);
  builder_.add_AttackerID(AttackerID);
  return builder_.Finish();
}

struct PlayerData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHARACTERNAME = 4,
    VT_PLAYER_NAME = 6,
    VT_HEALTH = 8,
    VT_PLAYERPOSITION = 10,
    VT_ISALIVE = 12,
    VT_ISATTACKING = 14,
    VT_ATTACKCOUNTNUMBER = 16,
    VT_ISSKILLUSING = 18,
    VT_SKILLNUMBER = 20
  };
  const flatbuffers::String *CharacterName() const {
    return GetPointer<const flatbuffers::String *>(VT_CHARACTERNAME);
  }
  int32_t player_name() const {
    return GetField<int32_t>(VT_PLAYER_NAME, 0);
  }
  int32_t health() const {
    return GetField<int32_t>(VT_HEALTH, 0);
  }
  const Position *playerPosition() const {
    return GetPointer<const Position *>(VT_PLAYERPOSITION);
  }
  bool IsAlive() const {
    return GetField<uint8_t>(VT_ISALIVE, 0) != 0;
  }
  bool IsAttacking() const {
    return GetField<uint8_t>(VT_ISATTACKING, 0) != 0;
  }
  int32_t AttackCountNumber() const {
    return GetField<int32_t>(VT_ATTACKCOUNTNUMBER, 0);
  }
  bool IsSkillUsing() const {
    return GetField<uint8_t>(VT_ISSKILLUSING, 0) != 0;
  }
  int32_t SkillNumber() const {
    return GetField<int32_t>(VT_SKILLNUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHARACTERNAME) &&
           verifier.VerifyString(CharacterName()) &&
           VerifyField<int32_t>(verifier, VT_PLAYER_NAME) &&
           VerifyField<int32_t>(verifier, VT_HEALTH) &&
           VerifyOffset(verifier, VT_PLAYERPOSITION) &&
           verifier.VerifyTable(playerPosition()) &&
           VerifyField<uint8_t>(verifier, VT_ISALIVE) &&
           VerifyField<uint8_t>(verifier, VT_ISATTACKING) &&
           VerifyField<int32_t>(verifier, VT_ATTACKCOUNTNUMBER) &&
           VerifyField<uint8_t>(verifier, VT_ISSKILLUSING) &&
           VerifyField<int32_t>(verifier, VT_SKILLNUMBER) &&
           verifier.EndTable();
  }
};

struct PlayerDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CharacterName(flatbuffers::Offset<flatbuffers::String> CharacterName) {
    fbb_.AddOffset(PlayerData::VT_CHARACTERNAME, CharacterName);
  }
  void add_player_name(int32_t player_name) {
    fbb_.AddElement<int32_t>(PlayerData::VT_PLAYER_NAME, player_name, 0);
  }
  void add_health(int32_t health) {
    fbb_.AddElement<int32_t>(PlayerData::VT_HEALTH, health, 0);
  }
  void add_playerPosition(flatbuffers::Offset<Position> playerPosition) {
    fbb_.AddOffset(PlayerData::VT_PLAYERPOSITION, playerPosition);
  }
  void add_IsAlive(bool IsAlive) {
    fbb_.AddElement<uint8_t>(PlayerData::VT_ISALIVE, static_cast<uint8_t>(IsAlive), 0);
  }
  void add_IsAttacking(bool IsAttacking) {
    fbb_.AddElement<uint8_t>(PlayerData::VT_ISATTACKING, static_cast<uint8_t>(IsAttacking), 0);
  }
  void add_AttackCountNumber(int32_t AttackCountNumber) {
    fbb_.AddElement<int32_t>(PlayerData::VT_ATTACKCOUNTNUMBER, AttackCountNumber, 0);
  }
  void add_IsSkillUsing(bool IsSkillUsing) {
    fbb_.AddElement<uint8_t>(PlayerData::VT_ISSKILLUSING, static_cast<uint8_t>(IsSkillUsing), 0);
  }
  void add_SkillNumber(int32_t SkillNumber) {
    fbb_.AddElement<int32_t>(PlayerData::VT_SKILLNUMBER, SkillNumber, 0);
  }
  explicit PlayerDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerDataBuilder &operator=(const PlayerDataBuilder &);
  flatbuffers::Offset<PlayerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerData> CreatePlayerData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> CharacterName = 0,
    int32_t player_name = 0,
    int32_t health = 0,
    flatbuffers::Offset<Position> playerPosition = 0,
    bool IsAlive = false,
    bool IsAttacking = false,
    int32_t AttackCountNumber = 0,
    bool IsSkillUsing = false,
    int32_t SkillNumber = 0) {
  PlayerDataBuilder builder_(_fbb);
  builder_.add_SkillNumber(SkillNumber);
  builder_.add_AttackCountNumber(AttackCountNumber);
  builder_.add_playerPosition(playerPosition);
  builder_.add_health(health);
  builder_.add_player_name(player_name);
  builder_.add_CharacterName(CharacterName);
  builder_.add_IsSkillUsing(IsSkillUsing);
  builder_.add_IsAttacking(IsAttacking);
  builder_.add_IsAlive(IsAlive);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerData> CreatePlayerDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *CharacterName = nullptr,
    int32_t player_name = 0,
    int32_t health = 0,
    flatbuffers::Offset<Position> playerPosition = 0,
    bool IsAlive = false,
    bool IsAttacking = false,
    int32_t AttackCountNumber = 0,
    bool IsSkillUsing = false,
    int32_t SkillNumber = 0) {
  return object::CreatePlayerData(
      _fbb,
      CharacterName ? _fbb.CreateString(CharacterName) : 0,
      player_name,
      health,
      playerPosition,
      IsAlive,
      IsAttacking,
      AttackCountNumber,
      IsSkillUsing,
      SkillNumber);
}

struct Position FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOC = 4,
    VT_ROT = 6,
    VT_VOC = 8
  };
  const Location *loc() const {
    return GetPointer<const Location *>(VT_LOC);
  }
  const Rotation *rot() const {
    return GetPointer<const Rotation *>(VT_ROT);
  }
  const Velocity *voc() const {
    return GetPointer<const Velocity *>(VT_VOC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOC) &&
           verifier.VerifyTable(loc()) &&
           VerifyOffset(verifier, VT_ROT) &&
           verifier.VerifyTable(rot()) &&
           VerifyOffset(verifier, VT_VOC) &&
           verifier.VerifyTable(voc()) &&
           verifier.EndTable();
  }
};

struct PositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_loc(flatbuffers::Offset<Location> loc) {
    fbb_.AddOffset(Position::VT_LOC, loc);
  }
  void add_rot(flatbuffers::Offset<Rotation> rot) {
    fbb_.AddOffset(Position::VT_ROT, rot);
  }
  void add_voc(flatbuffers::Offset<Velocity> voc) {
    fbb_.AddOffset(Position::VT_VOC, voc);
  }
  explicit PositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PositionBuilder &operator=(const PositionBuilder &);
  flatbuffers::Offset<Position> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Position>(end);
    return o;
  }
};

inline flatbuffers::Offset<Position> CreatePosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Location> loc = 0,
    flatbuffers::Offset<Rotation> rot = 0,
    flatbuffers::Offset<Velocity> voc = 0) {
  PositionBuilder builder_(_fbb);
  builder_.add_voc(voc);
  builder_.add_rot(rot);
  builder_.add_loc(loc);
  return builder_.Finish();
}

struct Location FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float X() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float Y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float Z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct LocationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_X(float X) {
    fbb_.AddElement<float>(Location::VT_X, X, 0.0f);
  }
  void add_Y(float Y) {
    fbb_.AddElement<float>(Location::VT_Y, Y, 0.0f);
  }
  void add_Z(float Z) {
    fbb_.AddElement<float>(Location::VT_Z, Z, 0.0f);
  }
  explicit LocationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LocationBuilder &operator=(const LocationBuilder &);
  flatbuffers::Offset<Location> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Location>(end);
    return o;
  }
};

inline flatbuffers::Offset<Location> CreateLocation(
    flatbuffers::FlatBufferBuilder &_fbb,
    float X = 0.0f,
    float Y = 0.0f,
    float Z = 0.0f) {
  LocationBuilder builder_(_fbb);
  builder_.add_Z(Z);
  builder_.add_Y(Y);
  builder_.add_X(X);
  return builder_.Finish();
}

struct Rotation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PITCH = 4,
    VT_ROLL = 6,
    VT_YAW = 8
  };
  float Pitch() const {
    return GetField<float>(VT_PITCH, 0.0f);
  }
  float Roll() const {
    return GetField<float>(VT_ROLL, 0.0f);
  }
  float Yaw() const {
    return GetField<float>(VT_YAW, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_PITCH) &&
           VerifyField<float>(verifier, VT_ROLL) &&
           VerifyField<float>(verifier, VT_YAW) &&
           verifier.EndTable();
  }
};

struct RotationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Pitch(float Pitch) {
    fbb_.AddElement<float>(Rotation::VT_PITCH, Pitch, 0.0f);
  }
  void add_Roll(float Roll) {
    fbb_.AddElement<float>(Rotation::VT_ROLL, Roll, 0.0f);
  }
  void add_Yaw(float Yaw) {
    fbb_.AddElement<float>(Rotation::VT_YAW, Yaw, 0.0f);
  }
  explicit RotationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RotationBuilder &operator=(const RotationBuilder &);
  flatbuffers::Offset<Rotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rotation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rotation> CreateRotation(
    flatbuffers::FlatBufferBuilder &_fbb,
    float Pitch = 0.0f,
    float Roll = 0.0f,
    float Yaw = 0.0f) {
  RotationBuilder builder_(_fbb);
  builder_.add_Yaw(Yaw);
  builder_.add_Roll(Roll);
  builder_.add_Pitch(Pitch);
  return builder_.Finish();
}

struct Velocity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VX = 4,
    VT_VY = 6,
    VT_VZ = 8
  };
  float VX() const {
    return GetField<float>(VT_VX, 0.0f);
  }
  float VY() const {
    return GetField<float>(VT_VY, 0.0f);
  }
  float VZ() const {
    return GetField<float>(VT_VZ, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VX) &&
           VerifyField<float>(verifier, VT_VY) &&
           VerifyField<float>(verifier, VT_VZ) &&
           verifier.EndTable();
  }
};

struct VelocityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_VX(float VX) {
    fbb_.AddElement<float>(Velocity::VT_VX, VX, 0.0f);
  }
  void add_VY(float VY) {
    fbb_.AddElement<float>(Velocity::VT_VY, VY, 0.0f);
  }
  void add_VZ(float VZ) {
    fbb_.AddElement<float>(Velocity::VT_VZ, VZ, 0.0f);
  }
  explicit VelocityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VelocityBuilder &operator=(const VelocityBuilder &);
  flatbuffers::Offset<Velocity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Velocity>(end);
    return o;
  }
};

inline flatbuffers::Offset<Velocity> CreateVelocity(
    flatbuffers::FlatBufferBuilder &_fbb,
    float VX = 0.0f,
    float VY = 0.0f,
    float VZ = 0.0f) {
  VelocityBuilder builder_(_fbb);
  builder_.add_VZ(VZ);
  builder_.add_VY(VY);
  builder_.add_VX(VX);
  return builder_.Finish();
}

struct GameResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RANK1_ID = 4,
    VT_RANK1_POINT = 6,
    VT_RANK2_ID = 8,
    VT_RANK2_POINT = 10,
    VT_RANK3_ID = 12,
    VT_RANK3_POINT = 14,
    VT_RANK4_ID = 16,
    VT_RANK4_POINT = 18,
    VT_DURINGDEFENSETIME = 20,
    VT_LEFTTOWERHP = 22,
    VT_KILLEDMONSTER = 24,
    VT_TOTALRECEIVEDDAMAGE = 26,
    VT_TOTALDIED = 28,
    VT_TOTALDAMAGETOMONSTER = 30,
    VT_KILLEDMONSTER_RARE = 32,
    VT_KILLEDMONSTER_BOSS = 34,
    VT_GETGOLD = 36
  };
  const flatbuffers::String *Rank1_ID() const {
    return GetPointer<const flatbuffers::String *>(VT_RANK1_ID);
  }
  int32_t Rank1_Point() const {
    return GetField<int32_t>(VT_RANK1_POINT, 0);
  }
  const flatbuffers::String *Rank2_ID() const {
    return GetPointer<const flatbuffers::String *>(VT_RANK2_ID);
  }
  int32_t Rank2_Point() const {
    return GetField<int32_t>(VT_RANK2_POINT, 0);
  }
  const flatbuffers::String *Rank3_ID() const {
    return GetPointer<const flatbuffers::String *>(VT_RANK3_ID);
  }
  int32_t Rank3_Point() const {
    return GetField<int32_t>(VT_RANK3_POINT, 0);
  }
  const flatbuffers::String *Rank4_ID() const {
    return GetPointer<const flatbuffers::String *>(VT_RANK4_ID);
  }
  int32_t Rank4_Point() const {
    return GetField<int32_t>(VT_RANK4_POINT, 0);
  }
  int32_t DuringDefenseTime() const {
    return GetField<int32_t>(VT_DURINGDEFENSETIME, 0);
  }
  int32_t LeftTowerHP() const {
    return GetField<int32_t>(VT_LEFTTOWERHP, 0);
  }
  int32_t KilledMonster() const {
    return GetField<int32_t>(VT_KILLEDMONSTER, 0);
  }
  int32_t TotalReceivedDamage() const {
    return GetField<int32_t>(VT_TOTALRECEIVEDDAMAGE, 0);
  }
  int32_t TotalDied() const {
    return GetField<int32_t>(VT_TOTALDIED, 0);
  }
  int32_t TotalDamageToMonster() const {
    return GetField<int32_t>(VT_TOTALDAMAGETOMONSTER, 0);
  }
  int32_t KilledMonster_Rare() const {
    return GetField<int32_t>(VT_KILLEDMONSTER_RARE, 0);
  }
  int32_t KilledMonster_Boss() const {
    return GetField<int32_t>(VT_KILLEDMONSTER_BOSS, 0);
  }
  int32_t GetGold() const {
    return GetField<int32_t>(VT_GETGOLD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RANK1_ID) &&
           verifier.VerifyString(Rank1_ID()) &&
           VerifyField<int32_t>(verifier, VT_RANK1_POINT) &&
           VerifyOffset(verifier, VT_RANK2_ID) &&
           verifier.VerifyString(Rank2_ID()) &&
           VerifyField<int32_t>(verifier, VT_RANK2_POINT) &&
           VerifyOffset(verifier, VT_RANK3_ID) &&
           verifier.VerifyString(Rank3_ID()) &&
           VerifyField<int32_t>(verifier, VT_RANK3_POINT) &&
           VerifyOffset(verifier, VT_RANK4_ID) &&
           verifier.VerifyString(Rank4_ID()) &&
           VerifyField<int32_t>(verifier, VT_RANK4_POINT) &&
           VerifyField<int32_t>(verifier, VT_DURINGDEFENSETIME) &&
           VerifyField<int32_t>(verifier, VT_LEFTTOWERHP) &&
           VerifyField<int32_t>(verifier, VT_KILLEDMONSTER) &&
           VerifyField<int32_t>(verifier, VT_TOTALRECEIVEDDAMAGE) &&
           VerifyField<int32_t>(verifier, VT_TOTALDIED) &&
           VerifyField<int32_t>(verifier, VT_TOTALDAMAGETOMONSTER) &&
           VerifyField<int32_t>(verifier, VT_KILLEDMONSTER_RARE) &&
           VerifyField<int32_t>(verifier, VT_KILLEDMONSTER_BOSS) &&
           VerifyField<int32_t>(verifier, VT_GETGOLD) &&
           verifier.EndTable();
  }
};

struct GameResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Rank1_ID(flatbuffers::Offset<flatbuffers::String> Rank1_ID) {
    fbb_.AddOffset(GameResult::VT_RANK1_ID, Rank1_ID);
  }
  void add_Rank1_Point(int32_t Rank1_Point) {
    fbb_.AddElement<int32_t>(GameResult::VT_RANK1_POINT, Rank1_Point, 0);
  }
  void add_Rank2_ID(flatbuffers::Offset<flatbuffers::String> Rank2_ID) {
    fbb_.AddOffset(GameResult::VT_RANK2_ID, Rank2_ID);
  }
  void add_Rank2_Point(int32_t Rank2_Point) {
    fbb_.AddElement<int32_t>(GameResult::VT_RANK2_POINT, Rank2_Point, 0);
  }
  void add_Rank3_ID(flatbuffers::Offset<flatbuffers::String> Rank3_ID) {
    fbb_.AddOffset(GameResult::VT_RANK3_ID, Rank3_ID);
  }
  void add_Rank3_Point(int32_t Rank3_Point) {
    fbb_.AddElement<int32_t>(GameResult::VT_RANK3_POINT, Rank3_Point, 0);
  }
  void add_Rank4_ID(flatbuffers::Offset<flatbuffers::String> Rank4_ID) {
    fbb_.AddOffset(GameResult::VT_RANK4_ID, Rank4_ID);
  }
  void add_Rank4_Point(int32_t Rank4_Point) {
    fbb_.AddElement<int32_t>(GameResult::VT_RANK4_POINT, Rank4_Point, 0);
  }
  void add_DuringDefenseTime(int32_t DuringDefenseTime) {
    fbb_.AddElement<int32_t>(GameResult::VT_DURINGDEFENSETIME, DuringDefenseTime, 0);
  }
  void add_LeftTowerHP(int32_t LeftTowerHP) {
    fbb_.AddElement<int32_t>(GameResult::VT_LEFTTOWERHP, LeftTowerHP, 0);
  }
  void add_KilledMonster(int32_t KilledMonster) {
    fbb_.AddElement<int32_t>(GameResult::VT_KILLEDMONSTER, KilledMonster, 0);
  }
  void add_TotalReceivedDamage(int32_t TotalReceivedDamage) {
    fbb_.AddElement<int32_t>(GameResult::VT_TOTALRECEIVEDDAMAGE, TotalReceivedDamage, 0);
  }
  void add_TotalDied(int32_t TotalDied) {
    fbb_.AddElement<int32_t>(GameResult::VT_TOTALDIED, TotalDied, 0);
  }
  void add_TotalDamageToMonster(int32_t TotalDamageToMonster) {
    fbb_.AddElement<int32_t>(GameResult::VT_TOTALDAMAGETOMONSTER, TotalDamageToMonster, 0);
  }
  void add_KilledMonster_Rare(int32_t KilledMonster_Rare) {
    fbb_.AddElement<int32_t>(GameResult::VT_KILLEDMONSTER_RARE, KilledMonster_Rare, 0);
  }
  void add_KilledMonster_Boss(int32_t KilledMonster_Boss) {
    fbb_.AddElement<int32_t>(GameResult::VT_KILLEDMONSTER_BOSS, KilledMonster_Boss, 0);
  }
  void add_GetGold(int32_t GetGold) {
    fbb_.AddElement<int32_t>(GameResult::VT_GETGOLD, GetGold, 0);
  }
  explicit GameResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameResultBuilder &operator=(const GameResultBuilder &);
  flatbuffers::Offset<GameResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameResult> CreateGameResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Rank1_ID = 0,
    int32_t Rank1_Point = 0,
    flatbuffers::Offset<flatbuffers::String> Rank2_ID = 0,
    int32_t Rank2_Point = 0,
    flatbuffers::Offset<flatbuffers::String> Rank3_ID = 0,
    int32_t Rank3_Point = 0,
    flatbuffers::Offset<flatbuffers::String> Rank4_ID = 0,
    int32_t Rank4_Point = 0,
    int32_t DuringDefenseTime = 0,
    int32_t LeftTowerHP = 0,
    int32_t KilledMonster = 0,
    int32_t TotalReceivedDamage = 0,
    int32_t TotalDied = 0,
    int32_t TotalDamageToMonster = 0,
    int32_t KilledMonster_Rare = 0,
    int32_t KilledMonster_Boss = 0,
    int32_t GetGold = 0) {
  GameResultBuilder builder_(_fbb);
  builder_.add_GetGold(GetGold);
  builder_.add_KilledMonster_Boss(KilledMonster_Boss);
  builder_.add_KilledMonster_Rare(KilledMonster_Rare);
  builder_.add_TotalDamageToMonster(TotalDamageToMonster);
  builder_.add_TotalDied(TotalDied);
  builder_.add_TotalReceivedDamage(TotalReceivedDamage);
  builder_.add_KilledMonster(KilledMonster);
  builder_.add_LeftTowerHP(LeftTowerHP);
  builder_.add_DuringDefenseTime(DuringDefenseTime);
  builder_.add_Rank4_Point(Rank4_Point);
  builder_.add_Rank4_ID(Rank4_ID);
  builder_.add_Rank3_Point(Rank3_Point);
  builder_.add_Rank3_ID(Rank3_ID);
  builder_.add_Rank2_Point(Rank2_Point);
  builder_.add_Rank2_ID(Rank2_ID);
  builder_.add_Rank1_Point(Rank1_Point);
  builder_.add_Rank1_ID(Rank1_ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameResult> CreateGameResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Rank1_ID = nullptr,
    int32_t Rank1_Point = 0,
    const char *Rank2_ID = nullptr,
    int32_t Rank2_Point = 0,
    const char *Rank3_ID = nullptr,
    int32_t Rank3_Point = 0,
    const char *Rank4_ID = nullptr,
    int32_t Rank4_Point = 0,
    int32_t DuringDefenseTime = 0,
    int32_t LeftTowerHP = 0,
    int32_t KilledMonster = 0,
    int32_t TotalReceivedDamage = 0,
    int32_t TotalDied = 0,
    int32_t TotalDamageToMonster = 0,
    int32_t KilledMonster_Rare = 0,
    int32_t KilledMonster_Boss = 0,
    int32_t GetGold = 0) {
  return object::CreateGameResult(
      _fbb,
      Rank1_ID ? _fbb.CreateString(Rank1_ID) : 0,
      Rank1_Point,
      Rank2_ID ? _fbb.CreateString(Rank2_ID) : 0,
      Rank2_Point,
      Rank3_ID ? _fbb.CreateString(Rank3_ID) : 0,
      Rank3_Point,
      Rank4_ID ? _fbb.CreateString(Rank4_ID) : 0,
      Rank4_Point,
      DuringDefenseTime,
      LeftTowerHP,
      KilledMonster,
      TotalReceivedDamage,
      TotalDied,
      TotalDamageToMonster,
      KilledMonster_Rare,
      KilledMonster_Boss,
      GetGold);
}

struct TopRanking FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REQUEST = 4,
    VT_RANKLIST = 6
  };
  bool request() const {
    return GetField<uint8_t>(VT_REQUEST, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<RankUser>> *ranklist() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RankUser>> *>(VT_RANKLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REQUEST) &&
           VerifyOffset(verifier, VT_RANKLIST) &&
           verifier.VerifyVector(ranklist()) &&
           verifier.VerifyVectorOfTables(ranklist()) &&
           verifier.EndTable();
  }
};

struct TopRankingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_request(bool request) {
    fbb_.AddElement<uint8_t>(TopRanking::VT_REQUEST, static_cast<uint8_t>(request), 0);
  }
  void add_ranklist(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RankUser>>> ranklist) {
    fbb_.AddOffset(TopRanking::VT_RANKLIST, ranklist);
  }
  explicit TopRankingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopRankingBuilder &operator=(const TopRankingBuilder &);
  flatbuffers::Offset<TopRanking> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopRanking>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopRanking> CreateTopRanking(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool request = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RankUser>>> ranklist = 0) {
  TopRankingBuilder builder_(_fbb);
  builder_.add_ranklist(ranklist);
  builder_.add_request(request);
  return builder_.Finish();
}

inline flatbuffers::Offset<TopRanking> CreateTopRankingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool request = false,
    const std::vector<flatbuffers::Offset<RankUser>> *ranklist = nullptr) {
  return object::CreateTopRanking(
      _fbb,
      request,
      ranklist ? _fbb.CreateVector<flatbuffers::Offset<RankUser>>(*ranklist) : 0);
}

struct RankUser FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USERID = 4,
    VT_POINT = 6
  };
  const flatbuffers::String *userid() const {
    return GetPointer<const flatbuffers::String *>(VT_USERID);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USERID) &&
           verifier.VerifyString(userid()) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           verifier.EndTable();
  }
};

struct RankUserBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_userid(flatbuffers::Offset<flatbuffers::String> userid) {
    fbb_.AddOffset(RankUser::VT_USERID, userid);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(RankUser::VT_POINT, point, 0);
  }
  explicit RankUserBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankUserBuilder &operator=(const RankUserBuilder &);
  flatbuffers::Offset<RankUser> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RankUser>(end);
    return o;
  }
};

inline flatbuffers::Offset<RankUser> CreateRankUser(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> userid = 0,
    int32_t point = 0) {
  RankUserBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_userid(userid);
  return builder_.Finish();
}

inline flatbuffers::Offset<RankUser> CreateRankUserDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *userid = nullptr,
    int32_t point = 0) {
  return object::CreateRankUser(
      _fbb,
      userid ? _fbb.CreateString(userid) : 0,
      point);
}

struct MonsterData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_NAME = 4,
    VT_HEALTH = 6,
    VT_MONSTERLOCATION = 8,
    VT_ISALIVE = 10,
    VT_ISATTACKING = 12,
    VT_ATTACKCOUNTNUMBER = 14,
    VT_MONSTERTYPE = 16
  };
  int32_t player_name() const {
    return GetField<int32_t>(VT_PLAYER_NAME, 0);
  }
  int32_t health() const {
    return GetField<int32_t>(VT_HEALTH, 0);
  }
  const Location *monsterLocation() const {
    return GetPointer<const Location *>(VT_MONSTERLOCATION);
  }
  bool IsAlive() const {
    return GetField<uint8_t>(VT_ISALIVE, 0) != 0;
  }
  bool IsAttacking() const {
    return GetField<uint8_t>(VT_ISATTACKING, 0) != 0;
  }
  int32_t AttackCountNumber() const {
    return GetField<int32_t>(VT_ATTACKCOUNTNUMBER, 0);
  }
  int32_t MonsterType() const {
    return GetField<int32_t>(VT_MONSTERTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYER_NAME) &&
           VerifyField<int32_t>(verifier, VT_HEALTH) &&
           VerifyOffset(verifier, VT_MONSTERLOCATION) &&
           verifier.VerifyTable(monsterLocation()) &&
           VerifyField<uint8_t>(verifier, VT_ISALIVE) &&
           VerifyField<uint8_t>(verifier, VT_ISATTACKING) &&
           VerifyField<int32_t>(verifier, VT_ATTACKCOUNTNUMBER) &&
           VerifyField<int32_t>(verifier, VT_MONSTERTYPE) &&
           verifier.EndTable();
  }
};

struct MonsterDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_name(int32_t player_name) {
    fbb_.AddElement<int32_t>(MonsterData::VT_PLAYER_NAME, player_name, 0);
  }
  void add_health(int32_t health) {
    fbb_.AddElement<int32_t>(MonsterData::VT_HEALTH, health, 0);
  }
  void add_monsterLocation(flatbuffers::Offset<Location> monsterLocation) {
    fbb_.AddOffset(MonsterData::VT_MONSTERLOCATION, monsterLocation);
  }
  void add_IsAlive(bool IsAlive) {
    fbb_.AddElement<uint8_t>(MonsterData::VT_ISALIVE, static_cast<uint8_t>(IsAlive), 0);
  }
  void add_IsAttacking(bool IsAttacking) {
    fbb_.AddElement<uint8_t>(MonsterData::VT_ISATTACKING, static_cast<uint8_t>(IsAttacking), 0);
  }
  void add_AttackCountNumber(int32_t AttackCountNumber) {
    fbb_.AddElement<int32_t>(MonsterData::VT_ATTACKCOUNTNUMBER, AttackCountNumber, 0);
  }
  void add_MonsterType(int32_t MonsterType) {
    fbb_.AddElement<int32_t>(MonsterData::VT_MONSTERTYPE, MonsterType, 0);
  }
  explicit MonsterDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MonsterDataBuilder &operator=(const MonsterDataBuilder &);
  flatbuffers::Offset<MonsterData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MonsterData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MonsterData> CreateMonsterData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t player_name = 0,
    int32_t health = 0,
    flatbuffers::Offset<Location> monsterLocation = 0,
    bool IsAlive = false,
    bool IsAttacking = false,
    int32_t AttackCountNumber = 0,
    int32_t MonsterType = 0) {
  MonsterDataBuilder builder_(_fbb);
  builder_.add_MonsterType(MonsterType);
  builder_.add_AttackCountNumber(AttackCountNumber);
  builder_.add_monsterLocation(monsterLocation);
  builder_.add_health(health);
  builder_.add_player_name(player_name);
  builder_.add_IsAttacking(IsAttacking);
  builder_.add_IsAlive(IsAlive);
  return builder_.Finish();
}

struct SystemMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4,
    VT_TYPE = 6
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct SystemMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(SystemMessage::VT_MESSAGE, message);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SystemMessage::VT_TYPE, type, 0);
  }
  explicit SystemMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SystemMessageBuilder &operator=(const SystemMessageBuilder &);
  flatbuffers::Offset<SystemMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SystemMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<SystemMessage> CreateSystemMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    int32_t type = 0) {
  SystemMessageBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<SystemMessage> CreateSystemMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    int32_t type = 0) {
  return object::CreateSystemMessage(
      _fbb,
      message ? _fbb.CreateString(message) : 0,
      type);
}

struct SystemTime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME = 4
  };
  int32_t Time() const {
    return GetField<int32_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct SystemTimeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Time(int32_t Time) {
    fbb_.AddElement<int32_t>(SystemTime::VT_TIME, Time, 0);
  }
  explicit SystemTimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SystemTimeBuilder &operator=(const SystemTimeBuilder &);
  flatbuffers::Offset<SystemTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SystemTime>(end);
    return o;
  }
};

inline flatbuffers::Offset<SystemTime> CreateSystemTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Time = 0) {
  SystemTimeBuilder builder_(_fbb);
  builder_.add_Time(Time);
  return builder_.Finish();
}

struct SpawnOK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FLAG = 4
  };
  bool flag() const {
    return GetField<uint8_t>(VT_FLAG, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLAG) &&
           verifier.EndTable();
  }
};

struct SpawnOKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flag(bool flag) {
    fbb_.AddElement<uint8_t>(SpawnOK::VT_FLAG, static_cast<uint8_t>(flag), 0);
  }
  explicit SpawnOKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpawnOKBuilder &operator=(const SpawnOKBuilder &);
  flatbuffers::Offset<SpawnOK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpawnOK>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpawnOK> CreateSpawnOK(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool flag = false) {
  SpawnOKBuilder builder_(_fbb);
  builder_.add_flag(flag);
  return builder_.Finish();
}

struct MoveMonster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WHICHMONSTER = 4
  };
  int32_t WhichMonster() const {
    return GetField<int32_t>(VT_WHICHMONSTER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WHICHMONSTER) &&
           verifier.EndTable();
  }
};

struct MoveMonsterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_WhichMonster(int32_t WhichMonster) {
    fbb_.AddElement<int32_t>(MoveMonster::VT_WHICHMONSTER, WhichMonster, 0);
  }
  explicit MoveMonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveMonsterBuilder &operator=(const MoveMonsterBuilder &);
  flatbuffers::Offset<MoveMonster> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveMonster>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveMonster> CreateMoveMonster(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t WhichMonster = 0) {
  MoveMonsterBuilder builder_(_fbb);
  builder_.add_WhichMonster(WhichMonster);
  return builder_.Finish();
}

struct MoveOK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FLAG = 4
  };
  bool flag() const {
    return GetField<uint8_t>(VT_FLAG, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLAG) &&
           verifier.EndTable();
  }
};

struct MoveOKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flag(bool flag) {
    fbb_.AddElement<uint8_t>(MoveOK::VT_FLAG, static_cast<uint8_t>(flag), 0);
  }
  explicit MoveOKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveOKBuilder &operator=(const MoveOKBuilder &);
  flatbuffers::Offset<MoveOK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveOK>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveOK> CreateMoveOK(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool flag = false) {
  MoveOKBuilder builder_(_fbb);
  builder_.add_flag(flag);
  return builder_.Finish();
}

struct SpawnMonsterData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_NAME = 4,
    VT_HEALTH = 6,
    VT_MONSTERLOCATION = 8,
    VT_MONSTERTYPE = 10,
    VT_ISALREADYSPAWN = 12
  };
  int32_t player_name() const {
    return GetField<int32_t>(VT_PLAYER_NAME, 0);
  }
  int32_t health() const {
    return GetField<int32_t>(VT_HEALTH, 0);
  }
  const Location *monsterLocation() const {
    return GetPointer<const Location *>(VT_MONSTERLOCATION);
  }
  int32_t MonsterType() const {
    return GetField<int32_t>(VT_MONSTERTYPE, 0);
  }
  bool IsAlreadySpawn() const {
    return GetField<uint8_t>(VT_ISALREADYSPAWN, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYER_NAME) &&
           VerifyField<int32_t>(verifier, VT_HEALTH) &&
           VerifyOffset(verifier, VT_MONSTERLOCATION) &&
           verifier.VerifyTable(monsterLocation()) &&
           VerifyField<int32_t>(verifier, VT_MONSTERTYPE) &&
           VerifyField<uint8_t>(verifier, VT_ISALREADYSPAWN) &&
           verifier.EndTable();
  }
};

struct SpawnMonsterDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_name(int32_t player_name) {
    fbb_.AddElement<int32_t>(SpawnMonsterData::VT_PLAYER_NAME, player_name, 0);
  }
  void add_health(int32_t health) {
    fbb_.AddElement<int32_t>(SpawnMonsterData::VT_HEALTH, health, 0);
  }
  void add_monsterLocation(flatbuffers::Offset<Location> monsterLocation) {
    fbb_.AddOffset(SpawnMonsterData::VT_MONSTERLOCATION, monsterLocation);
  }
  void add_MonsterType(int32_t MonsterType) {
    fbb_.AddElement<int32_t>(SpawnMonsterData::VT_MONSTERTYPE, MonsterType, 0);
  }
  void add_IsAlreadySpawn(bool IsAlreadySpawn) {
    fbb_.AddElement<uint8_t>(SpawnMonsterData::VT_ISALREADYSPAWN, static_cast<uint8_t>(IsAlreadySpawn), 0);
  }
  explicit SpawnMonsterDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpawnMonsterDataBuilder &operator=(const SpawnMonsterDataBuilder &);
  flatbuffers::Offset<SpawnMonsterData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpawnMonsterData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpawnMonsterData> CreateSpawnMonsterData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t player_name = 0,
    int32_t health = 0,
    flatbuffers::Offset<Location> monsterLocation = 0,
    int32_t MonsterType = 0,
    bool IsAlreadySpawn = false) {
  SpawnMonsterDataBuilder builder_(_fbb);
  builder_.add_MonsterType(MonsterType);
  builder_.add_monsterLocation(monsterLocation);
  builder_.add_health(health);
  builder_.add_player_name(player_name);
  builder_.add_IsAlreadySpawn(IsAlreadySpawn);
  return builder_.Finish();
}

struct MyData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HP = 4,
    VT_POINT = 6,
    VT_POTION100 = 8,
    VT_POTION50 = 10
  };
  int32_t HP() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t Point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  int32_t Potion100() const {
    return GetField<int32_t>(VT_POTION100, 0);
  }
  int32_t Potion50() const {
    return GetField<int32_t>(VT_POTION50, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           VerifyField<int32_t>(verifier, VT_POTION100) &&
           VerifyField<int32_t>(verifier, VT_POTION50) &&
           verifier.EndTable();
  }
};

struct MyDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_HP(int32_t HP) {
    fbb_.AddElement<int32_t>(MyData::VT_HP, HP, 0);
  }
  void add_Point(int32_t Point) {
    fbb_.AddElement<int32_t>(MyData::VT_POINT, Point, 0);
  }
  void add_Potion100(int32_t Potion100) {
    fbb_.AddElement<int32_t>(MyData::VT_POTION100, Potion100, 0);
  }
  void add_Potion50(int32_t Potion50) {
    fbb_.AddElement<int32_t>(MyData::VT_POTION50, Potion50, 0);
  }
  explicit MyDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MyDataBuilder &operator=(const MyDataBuilder &);
  flatbuffers::Offset<MyData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MyData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MyData> CreateMyData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t HP = 0,
    int32_t Point = 0,
    int32_t Potion100 = 0,
    int32_t Potion50 = 0) {
  MyDataBuilder builder_(_fbb);
  builder_.add_Potion50(Potion50);
  builder_.add_Potion100(Potion100);
  builder_.add_Point(Point);
  builder_.add_HP(HP);
  return builder_.Finish();
}

struct Revival FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ISPERFECT = 4
  };
  bool IsPerfect() const {
    return GetField<uint8_t>(VT_ISPERFECT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ISPERFECT) &&
           verifier.EndTable();
  }
};

struct RevivalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_IsPerfect(bool IsPerfect) {
    fbb_.AddElement<uint8_t>(Revival::VT_ISPERFECT, static_cast<uint8_t>(IsPerfect), 0);
  }
  explicit RevivalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RevivalBuilder &operator=(const RevivalBuilder &);
  flatbuffers::Offset<Revival> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Revival>(end);
    return o;
  }
};

inline flatbuffers::Offset<Revival> CreateRevival(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool IsPerfect = false) {
  RevivalBuilder builder_(_fbb);
  builder_.add_IsPerfect(IsPerfect);
  return builder_.Finish();
}

struct GameEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ISEND = 4
  };
  bool IsEnd() const {
    return GetField<uint8_t>(VT_ISEND, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ISEND) &&
           verifier.EndTable();
  }
};

struct GameEndBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_IsEnd(bool IsEnd) {
    fbb_.AddElement<uint8_t>(GameEnd::VT_ISEND, static_cast<uint8_t>(IsEnd), 0);
  }
  explicit GameEndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameEndBuilder &operator=(const GameEndBuilder &);
  flatbuffers::Offset<GameEnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameEnd> CreateGameEnd(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool IsEnd = false) {
  GameEndBuilder builder_(_fbb);
  builder_.add_IsEnd(IsEnd);
  return builder_.Finish();
}

struct ItemUsing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_USERID = 6
  };
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t UserID() const {
    return GetField<int32_t>(VT_USERID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_USERID) &&
           verifier.EndTable();
  }
};

struct ItemUsingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(ItemUsing::VT_TYPE, Type, 0);
  }
  void add_UserID(int32_t UserID) {
    fbb_.AddElement<int32_t>(ItemUsing::VT_USERID, UserID, 0);
  }
  explicit ItemUsingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ItemUsingBuilder &operator=(const ItemUsingBuilder &);
  flatbuffers::Offset<ItemUsing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemUsing>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemUsing> CreateItemUsing(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Type = 0,
    int32_t UserID = 0) {
  ItemUsingBuilder builder_(_fbb);
  builder_.add_UserID(UserID);
  builder_.add_Type(Type);
  return builder_.Finish();
}

struct RefreshItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENTGOLD = 4,
    VT_CURRENTPOTION100 = 6,
    VT_CURRENTPOTION50 = 8
  };
  int32_t CurrentGold() const {
    return GetField<int32_t>(VT_CURRENTGOLD, 0);
  }
  int32_t CurrentPotion100() const {
    return GetField<int32_t>(VT_CURRENTPOTION100, 0);
  }
  int32_t CurrentPotion50() const {
    return GetField<int32_t>(VT_CURRENTPOTION50, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CURRENTGOLD) &&
           VerifyField<int32_t>(verifier, VT_CURRENTPOTION100) &&
           VerifyField<int32_t>(verifier, VT_CURRENTPOTION50) &&
           verifier.EndTable();
  }
};

struct RefreshItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CurrentGold(int32_t CurrentGold) {
    fbb_.AddElement<int32_t>(RefreshItem::VT_CURRENTGOLD, CurrentGold, 0);
  }
  void add_CurrentPotion100(int32_t CurrentPotion100) {
    fbb_.AddElement<int32_t>(RefreshItem::VT_CURRENTPOTION100, CurrentPotion100, 0);
  }
  void add_CurrentPotion50(int32_t CurrentPotion50) {
    fbb_.AddElement<int32_t>(RefreshItem::VT_CURRENTPOTION50, CurrentPotion50, 0);
  }
  explicit RefreshItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RefreshItemBuilder &operator=(const RefreshItemBuilder &);
  flatbuffers::Offset<RefreshItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RefreshItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<RefreshItem> CreateRefreshItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t CurrentGold = 0,
    int32_t CurrentPotion100 = 0,
    int32_t CurrentPotion50 = 0) {
  RefreshItemBuilder builder_(_fbb);
  builder_.add_CurrentPotion50(CurrentPotion50);
  builder_.add_CurrentPotion100(CurrentPotion100);
  builder_.add_CurrentGold(CurrentGold);
  return builder_.Finish();
}

struct ItemBuy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POTION_100 = 4,
    VT_POTION_50 = 6,
    VT_TOTALPRICE = 8
  };
  int32_t Potion_100() const {
    return GetField<int32_t>(VT_POTION_100, 0);
  }
  int32_t Potion_50() const {
    return GetField<int32_t>(VT_POTION_50, 0);
  }
  int32_t TotalPrice() const {
    return GetField<int32_t>(VT_TOTALPRICE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POTION_100) &&
           VerifyField<int32_t>(verifier, VT_POTION_50) &&
           VerifyField<int32_t>(verifier, VT_TOTALPRICE) &&
           verifier.EndTable();
  }
};

struct ItemBuyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Potion_100(int32_t Potion_100) {
    fbb_.AddElement<int32_t>(ItemBuy::VT_POTION_100, Potion_100, 0);
  }
  void add_Potion_50(int32_t Potion_50) {
    fbb_.AddElement<int32_t>(ItemBuy::VT_POTION_50, Potion_50, 0);
  }
  void add_TotalPrice(int32_t TotalPrice) {
    fbb_.AddElement<int32_t>(ItemBuy::VT_TOTALPRICE, TotalPrice, 0);
  }
  explicit ItemBuyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ItemBuyBuilder &operator=(const ItemBuyBuilder &);
  flatbuffers::Offset<ItemBuy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemBuy>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemBuy> CreateItemBuy(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Potion_100 = 0,
    int32_t Potion_50 = 0,
    int32_t TotalPrice = 0) {
  ItemBuyBuilder builder_(_fbb);
  builder_.add_TotalPrice(TotalPrice);
  builder_.add_Potion_50(Potion_50);
  builder_.add_Potion_100(Potion_100);
  return builder_.Finish();
}

struct BuyRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REQUEST = 4
  };
  bool request() const {
    return GetField<uint8_t>(VT_REQUEST, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REQUEST) &&
           verifier.EndTable();
  }
};

struct BuyRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_request(bool request) {
    fbb_.AddElement<uint8_t>(BuyRequest::VT_REQUEST, static_cast<uint8_t>(request), 0);
  }
  explicit BuyRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuyRequestBuilder &operator=(const BuyRequestBuilder &);
  flatbuffers::Offset<BuyRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuyRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BuyRequest> CreateBuyRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool request = false) {
  BuyRequestBuilder builder_(_fbb);
  builder_.add_request(request);
  return builder_.Finish();
}

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_LoginData: {
      auto ptr = reinterpret_cast<const LoginData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_SignUpData: {
      auto ptr = reinterpret_cast<const SignUpData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GameState: {
      auto ptr = reinterpret_cast<const GameState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_AllUser: {
      auto ptr = reinterpret_cast<const AllUser *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_RoomInfo: {
      auto ptr = reinterpret_cast<const RoomInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_RoomList: {
      auto ptr = reinterpret_cast<const RoomList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GameReadyInfo: {
      auto ptr = reinterpret_cast<const GameReadyInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_LeaveRoom: {
      auto ptr = reinterpret_cast<const LeaveRoom *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GameStartInfo: {
      auto ptr = reinterpret_cast<const GameStartInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_CheckPassword: {
      auto ptr = reinterpret_cast<const CheckPassword *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_ChatMessage: {
      auto ptr = reinterpret_cast<const ChatMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_AttackInfo: {
      auto ptr = reinterpret_cast<const AttackInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_PlayerData: {
      auto ptr = reinterpret_cast<const PlayerData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GameResult: {
      auto ptr = reinterpret_cast<const GameResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_TopRanking: {
      auto ptr = reinterpret_cast<const TopRanking *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_MonsterData: {
      auto ptr = reinterpret_cast<const MonsterData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_SystemMessage: {
      auto ptr = reinterpret_cast<const SystemMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_SystemTime: {
      auto ptr = reinterpret_cast<const SystemTime *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_SpawnOK: {
      auto ptr = reinterpret_cast<const SpawnOK *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_MoveMonster: {
      auto ptr = reinterpret_cast<const MoveMonster *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_MoveOK: {
      auto ptr = reinterpret_cast<const MoveOK *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_SpawnMonsterData: {
      auto ptr = reinterpret_cast<const SpawnMonsterData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_MyData: {
      auto ptr = reinterpret_cast<const MyData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Revival: {
      auto ptr = reinterpret_cast<const Revival *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GameEnd: {
      auto ptr = reinterpret_cast<const GameEnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_ItemUsing: {
      auto ptr = reinterpret_cast<const ItemUsing *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_RefreshItem: {
      auto ptr = reinterpret_cast<const RefreshItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_ItemBuy: {
      auto ptr = reinterpret_cast<const ItemBuy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_BuyRequest: {
      auto ptr = reinterpret_cast<const BuyRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const object::Packet *GetPacket(const void *buf) {
  return flatbuffers::GetRoot<object::Packet>(buf);
}

inline const object::Packet *GetSizePrefixedPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<object::Packet>(buf);
}

inline bool VerifyPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<object::Packet>(nullptr);
}

inline bool VerifySizePrefixedPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<object::Packet>(nullptr);
}

inline void FinishPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<object::Packet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<object::Packet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace object

#endif  // FLATBUFFERS_GENERATED_FLATPACKET_OBJECT_H_
